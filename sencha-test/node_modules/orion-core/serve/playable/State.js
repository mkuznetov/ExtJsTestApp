ST.playable.define('State', {
    ready: function () {
        var me = this,
            is = me.is,
            wait = me.wait,
            args = me.args || [];

        if (!wait) {
            if (this.animationsDone() && this.targetReady()) {
                if (!is.apply(me, args)) {
                    return this.setWaiting(me.type, 'true');
                }
                return this.setWaiting(false);
            }
            return false;
        } else {
            return true;
        }
    },

    fn: function (done) {
        var me = this,
            is = me.is,
            wait = me.wait,
            args = me.args || [],
            eventName, i, fn;

        if (wait) {
            // Set up wait() for string/array of defined event names
            if (typeof wait !== 'function') {
                // save the eventName (array of String or function) for the timeout 
                // message below in our local fn function.
                me.eventName = eventName = (typeof wait === 'string') ? [wait] : wait;

                wait = function (done) {
                    var me = this,
                        cmp = me.getComponent(),
                        listener = {},
                        fn, timer;

                    fn = function () {
                        if (is.apply(me, args)) {
                            if (timer) {
                                ST.deferCancel(timer);
                            }

                            cmp.un(listener);
                            done();
                            done = ST.emptyFn;
                        } else if (!timer) {
                            timer = ST.defer(function () {
                                timer = null;

                                if (is.apply(me, args)) {
                                    cmp.un(listener);
                                    done();
                                    done = ST.emptyFn;
                                }
                            }, 0);
                        }
                    }

                    for (i = 0; i < eventName.length; i++) {
                        listener[eventName[i]] = fn;
                    }

                    cmp.on(listener);

                    return function () {
                        cmp.un(listener);
                    };
                };
            }

            fn = function () {
                if (ST.LOGME) console.log('State, fn = function, this.timeout='+this.timeout);

                var me = this, // the event (Playable)
                    timeDiff = me.watchdogStarted ? (new Date().getTime() - me.watchdogStarted) : 0,
                    timeout = me.timeout - timeDiff - 1,
                // With a wait() we can just schedule in a call to advance
                // instead of polling the is() method.
                    args = ST.Array.slice(arguments), // just for the unwait bit down below...
                    timer, unwait;

                if (is.apply(me, args)) {
                    done();
                } else {
                    me.setWaiting(me.type, 'true');

                    args.unshift(function () { // the done function to use later in unwait...
                        if (timer) {
                            timer = timer(); // call cancelFn
                            me.setWaiting(false);
                            done();
                        }
                    });

                    unwait = wait.apply(me, args);

                    // This timer is a bit tricky, if it pops after a playable fn watchdog pops
                    // then things might not work quite right especially if components are 
                    // destroyed in an afterEach or afterAll function.
                    timer = ST.timeout(function () {
                        timer = 0;
                        unwait();
                        if (me.eventName) {
                            done.fail('Timedout waiting for event(s): '+me.eventName);
                        } else {
                            done.fail('Timedout waiting for wait function');
                        }
                    }, timeout);
                }
            };
            return fn.call(me);
        } else {
            done();
        }
    }
});
